<!DOCTYPE html><head><meta charset='utf-8'/>
   <title>Phoenix Point research browser</title>
<style>
* { box-sizing: border-box; }
div, p, span, ul, ol, li, h1, h2, h3, h4, h5, h6 { margin: 0; padding: 0; }
nav { display: none; }
h3 { margin-top: 1ex; }
   h3 > span { padding-left: 1em; font-size: 90%; font-weight: normal; }
</style>
</head><body>
   <nav>
      <label>Data XML: <input type='file' multiple accept=".xml"/></label> <button id='btnLoad'>Refresh</button>
      <label><input type='checkbox' id='chkDesc'>Descriptions</label>
   </nav>
   <main><br>Please select the xml files dumped by the <a href='https://www.nexusmods.com/phoenixpoint/mods/50'>Dump Data</a> mod, all 20+ of them.<br><br>All data will be processed locally; nothing will be uploaded.</main>
<script>(()=>{
qs( 'nav' ).style.display = 'block';
qs( '#btnLoad' ).addEventListener( 'click', () => loadFiles( true ) )
qs( '#chkDesc' ).addEventListener( 'change', () => loadFiles( false ) )
qs( 'input[type=file]' ).addEventListener( 'input', () => loadFiles( false ) );
if ( qs( 'input[type=file]' ).files.length ) loadFiles( false );

const defs = new Map(), byType = new Map();

async function loadFiles ( forceLoad ) {
   [ ... qsa( 'nav input, nav button' ) ].forEach( e => e.disabled = true );
   try {
      const files = qs( 'input[type=file]' ).files;
      if ( files.length <= 0 ) return;
      const docs = ( await Promise.allSettled( [ ... files ].map( e => e.text() ) ) )
         .filter( e => e?.status === 'fulfilled' )
         .map( e => new DOMParser().parseFromString( e.value, 'text/xml' ).documentElement )
         .filter( e => e?.tagName !== 'parsererror' );
      if ( ! docs.length ) return;

      defs.clear();
      byType.clear();
      const main = qs( 'main' );
      main.textContent = '';
      for ( let doc of docs ) {
         const type = doc.tagName;
         for ( let e of doc.children ) {
            if ( ! e.hasAttribute( 'guid' ) ) continue;
            addToDef( e, type === e.tagName ? [ type ] : [ type, e.tagName ] );
         }
      }
      render();
   } catch ( err ) {
      console.error( err );
   } finally {
      [ ... qsa( 'nav input, nav button' ) ].forEach( e => e.disabled = false );
   }
}

function addToDef ( element, types = [] ) {
   const guid = element.getAttribute( 'guid' );
   if ( ! element.childElementCount ) return; // Not interested in empty data
   for ( let e of element.children )
      recurAddDef( e );
   if ( ! defs.has( guid ) ) {
      defs.set( guid, element );
      for ( let t of types ) {
         let list = byType.get( t );
         if ( ! list ) byType.set( t, list = [] );
         list.push( element );
      }
   } else // Remove children from duplicate data
      for ( let e of element.children )
         e.remove();
}

function recurAddDef ( element ) {
   if ( element.hasAttribute( 'guid' ) )
      addToDef( element );
   else if ( element.childElementCount )
      for ( let e of element.children )
         recurAddDef( e );
}

function render () {
   const showDesc = qs( 'input#chkDesc' ).checked;
   const main = qs( 'main' );
   if ( ! byType.has( 'ResearchDef' ) )
      return main.textContent = 'No research data found';
   const namePairs = [];
   for ( let def of byType.get( 'ResearchDef' ) ) {
      const name = getName( def, 1 );
      namePairs.push( [ name, def ] );
   }
   namePairs.sort( (a,b) => ( a[0] > b[0] ? 1 : ( a[0] === b[0] ? 0 : -1 ) ) );
   add( main, ce( 'h2', 'Research' ) );
   for ( let [ name, def ] of namePairs ) {
      const view = xpa( def, 'ViewElementDef' )[0];

      const cost = xps( def, 'ResearchCost/@val' ), faction = factionAbbr( xps( def, 'Faction/@guid' ) );
      let subtitle = '', body = '';
      if ( cost ) subtitle += cost + ' ';
      if ( faction ) subtitle += faction + ' ';
      subtitle += def.getAttribute( 'guid' );
      title = ce( 'h3', esc( name ) + ce( 'span', esc( subtitle ) ) );

      const initFac = xpa( def, 'InitialStates//State[not(@val="Hidden")]' );
      if ( initFac ) body += 'Starts Revealed: ' + initFac.map( e => factionAbbr( e.previousElementSibling ) + ` (${e.getAttribute('val')})` ).join( ', ' ) + '<br>';

      if ( showDesc ) {
         const preText = xps( view, 'UnlockText/text()' ), postText = xps( view, 'CompleteText/text()' );
         if ( preText?.startsWith( '<!-MISSING KEY' ) === false ) body += '< ' + esc( preText ) + '<br>';
         if ( postText?.startsWith( '<!-MISSING KEY' ) === false && preText !== postText ) body += '> ' + esc( postText ) + '<br>';
      }

      const unlocks = [];
      xpa( def, 'Resources/LI.ResourceUnit/Type' )?.forEach( e => unlocks.push( e.getAttribute( 'val' ) + ' ' + e.nextElementSibling.getAttribute( 'val' ) ) );
      xpa( def, 'Unlocks/*' )?.forEach( e => unlocks.push( reward2Txt( e ) ) );
      if ( unlocks.length )
         body += 'Unlocks: ' + unlocks.join( ', ' );

      add( main, ce( 'div', title + ce( 'p', body ) ) );
   }
}

function uncap ( text ) { return text?.split( / +/g ).map( e => e[0] + e.substr( 1 ).toLowerCase() ).join( ' ' ); }
function camel2words ( text ) { return [ ... text.matchAll( /[A-Z]+[a-z]*/g ) ].map( e => e[0] ).join( ' ' ); }
function esc ( text ) { return text?.replaceAll( /[&<>"']/g, e => '&'+({"&":'amp',"<":'lt',">":'gt',"\"":'quot',"'":'#039'})[e]+';' ); }
function xpa ( ele, path ) {
   let it = ele?.ownerDocument.evaluate( './' + path, ele, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null ), result = [], e;
   while ( ( e = it?.iterateNext() ) !== null ) result.push( e );
   return result.length ? result : null;
}
function xpn ( ele, path ) { return ele?.ownerDocument.evaluate( './' + path, ele, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null )?.singleNodeValue; }
function xps ( ele, path ) { return ele?.ownerDocument.evaluate( './' + path, ele, null, XPathResult.STRING_TYPE, null )?.stringValue; }

function qs ( root, selector = null ) { if ( ! selector ) [ root, selector ] = [ document, root ]; return root.querySelector( selector ); }
function qsa ( root, selector = null ) { if ( ! selector ) [ root, selector ] = [ document, root ]; return root.querySelectorAll( selector ); }
function add ( ele, html, pos = 'beforeend' ) { return ele.insertAdjacentHTML( pos, html ); }
function ce ( tag, content, prop = {} ) {
   let open = '<' + tag;
   if ( prop )
      for ( let p in prop )
         open += ' ' + p + '="' + esc( prop[p] ) + '"';
   return open + '>' + content + '</' + tag + '>';
}

function getDef ( guid, path ) {
   if ( path ) guid = xps( guid, path + '/@guid' );
   else if ( guid.hasAttribute && guid.hasAttribute( 'guid' ) ) guid = guid.getAttribute( 'guid' );
   return defs.get( guid );
}

function getName ( def, name = 0 ) {
   let ele = typeof( def ) === 'string' ? defs.get( def ) : def, id = ele.getAttribute( 'name' );
   if ( ele.getAttribute( 'null' ) ) return '';
   else if ( ! ele.childElementCount ) ele = defs.get( ele.getAttribute( 'guid' ) );
   if ( ! ele ) debugger;
   switch ( name ) {
      case 0 :
         return uncap( xps( ele , "*[starts-with(local-name(),'ViewElement')]/Name/@val" ) ) || id;
      case 1 :
         return uncap( xps( ele , "*[starts-with(local-name(),'ViewElement')]/DisplayName1/text()" ) ) || id;
      case 2 :
         return uncap( xps( ele , "*[starts-with(local-name(),'ViewElement')]/DisplayName2/text()" ) ) || id;
      case 3 :
         return uncap( xps( ele , "*[starts-with(local-name(),'ViewElement')]/DisplayName2/text()" ) || xps( ele , "*[starts-with(local-name(),'ViewElement')]/DisplayName1/text()" ) ) || id;
   }
   return id;
}

function factionAbbr ( fac ) {
   if ( fac.getAttribute ) fac = fac.getAttribute( 'guid' );
   switch ( fac ) {
      case '8be7e872-0ad2-a2a4-7bee-c980ed304a8a' : return 'PX';
      case 'cf8eea9a-f47a-79c4-cb3b-7a484831dede' : return 'ALN';
      case 'edc6783a-be00-1a84-2b97-2fe1e0fc5448' : return 'ANU';
      case 'd31c78b9-ff0e-8b94-ab96-9672da73da54' : return 'NJ';
      case '0e6dc218-e157-5954-c9ab-1a0606e0d914' : return 'SYN';
      default: return fac;
   }
}

function reward2Txt ( ele ) {
   switch ( ele.tagName.substr( 3 ) ) {
      case 'AircraftBuffResearchRewardDef' :
         return ( getName( xpn( ele, 'VehicleDef' ), 2 ) || 'Aircrafts' ) + ' '
            + xpa( ele, 'ModData/*' ).map( e => e.tagName + ' x' + e.getAttribute( 'val' ) ).join( ' & ' );
      case 'AlienBaseTypeResearchRewardDef' :
         return uncap( xps( getDef( ele, 'BaseType' ), 'Name/text()' ) );
      case 'CharacterStatResearchRewardDef' :
         return 'Unit ' + xpa( getDef( ele, 'PassiveModifierAbilityDef' ), 'StatModifications/*' ).map( buff2Txt ).join( ' & ' );
      case 'ClassResearchRewardDef' :
         return 'Class ' + getName( getDef( ele, 'SpecializationDef' ), 1 );
      case 'EncounterVarResearchRewardDef' :
         let fac = xpa( ele, 'ValidForFactions/*' ), varOp = 'Flag ' + xps( ele, 'VariableName/@val' )
            + ( xps( ele, 'IsSetOperation/@val' ) === 'True' ? '=' : '+' ) + xps( ele, 'VariableValue/@val' );
         if ( fac.length ) return fac.map( e => factionAbbr( e ) ).join( ' & ' ) + ' ' + varOp;
         return varOp;
      case 'FacilityResearchRewardDef' :
         return xpa( ele, 'Facilities/*' ).map( e => getName( getDef( e ), 1 ) ).join( ', ' );
      case 'ManufactureResearchRewardDef' :
         return xpa( ele, 'Items/*' ).map( e => getName( getDef( e ), 3 ) ).join( ', ' );
      case 'UnitTemplateResearchRewardDef' :
         return 'New Enemy';
      case 'UnlockFunctionalityResearchRewardDef' :
         return 'New Function';
      case 'FacilityBuffResearchRewardDef' :
      case 'FactionModifierResearchRewardDef' :
      case 'HavenZoneResearchRewardDef' :
      case 'HavenZoneBuffResearchRewardDef' :
      case 'ResearchBonusResearchRewardDef' :
      case 'StatusBuffResearchRewardDef' :
         return 'Some Buff';
   }
   return ele.tagName.substr( 3 );
}

function buff2Txt ( ele ) {
   let op = xps( ele, 'Modification/@val' );
   switch ( op ) {
      case 'Add' : op = '+'; break;
   }
   return xps( ele, 'TargetStat/@val' ) + ' ' + op + xps( ele, 'Value/@val' );
}

window.getPPDef = ( guid = '' ) => guid ? defs.get( guid ) : defs;
window.getPPType = ( type = '' ) => type ? byType.get( type ) : byType;

})()</script><noscript>
   <h1>Requires JavaScript</h1>
</noscript>
</body></html>